# GitLab CI/CD: Full AutoDevOps Pipeline
# Triggers on main/master branch push and manual runs
# Features: Security scan, parallel Docker builds, automated deployment, health verification, rollback

stages:
  - validate
  - security
  - build
  - deploy
  - verify
  - cleanup

variables:
  # GitLab-provided variables (auto-configured)
  # CI_REGISTRY: registry.jclee.me
  # CI_REGISTRY_USER: gitlab-ci-token
  # CI_REGISTRY_PASSWORD: $CI_JOB_TOKEN
  # CI_REGISTRY_IMAGE: registry.jclee.me/jclee/blacklist

  # Docker build optimization
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_BUILDKIT: 1

  # Component image names
  IMAGE_POSTGRES: "${CI_REGISTRY_IMAGE}/blacklist-postgres"
  IMAGE_REDIS: "${CI_REGISTRY_IMAGE}/blacklist-redis"
  IMAGE_COLLECTOR: "${CI_REGISTRY_IMAGE}/blacklist-collector"
  IMAGE_APP: "${CI_REGISTRY_IMAGE}/blacklist-app"
  IMAGE_FRONTEND: "${CI_REGISTRY_IMAGE}/blacklist-frontend"

# ============================================================================
# VALIDATE STAGE - Quick environment checks
# ============================================================================

validate:environment:
  stage: validate
  image: alpine:latest
  script:
    - echo "[OK] GitLab CI/CD environment validation"
    - echo "CI_COMMIT_BRANCH=$CI_COMMIT_BRANCH"
    - echo "CI_REGISTRY=$CI_REGISTRY"
    - echo "CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE"
    - echo "CI_COMMIT_SHA=$CI_COMMIT_SHA"
    - echo "[OK] Validation passed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

# ============================================================================
# SECURITY STAGE - Dependency scanning
# ============================================================================

security:python-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    - pip install safety
  script:
    - echo "[SECURITY] Scanning Python dependencies for vulnerabilities..."

    # Scan app dependencies
    - |
      if [ -f app/requirements.txt ]; then
        echo "[SCAN] Checking app/requirements.txt..."
        safety check --file=app/requirements.txt --json > app-safety-report.json || true
        safety check --file=app/requirements.txt || echo "[WARN] Vulnerabilities found in app dependencies"
      fi

    # Scan collector dependencies
    - |
      if [ -f collector/requirements.txt ]; then
        echo "[SCAN] Checking collector/requirements.txt..."
        safety check --file=collector/requirements.txt --json > collector-safety-report.json || true
        safety check --file=collector/requirements.txt || echo "[WARN] Vulnerabilities found in collector dependencies"
      fi

    - echo "[OK] Python security scan completed"

  artifacts:
    paths:
      - "*-safety-report.json"
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: true

security:javascript-scan:
  stage: security
  image: node:20-slim
  script:
    - echo "[SECURITY] Scanning JavaScript dependencies for vulnerabilities..."

    # Scan frontend dependencies
    - |
      if [ -f frontend/package.json ]; then
        cd frontend
        echo "[SCAN] Checking frontend dependencies..."
        npm audit --json > ../frontend-audit-report.json || true
        npm audit --audit-level=moderate || echo "[WARN] Vulnerabilities found in frontend dependencies"
        cd ..
      fi

    - echo "[OK] JavaScript security scan completed"

  artifacts:
    paths:
      - "*-audit-report.json"
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: true

security:run-tests:
  stage: security
  image: python:3.11-slim
  before_script:
    - cd app
    - pip install -r requirements.txt
  script:
    - echo "[TEST] Running test suite..."
    - pytest --cov=core --cov-report=term-missing --cov-report=xml || echo "[WARN] Some tests failed"
    - echo "[OK] Tests completed"

  artifacts:
    paths:
      - app/coverage.xml
    reports:
      coverage_report:
        coverage_format: cobertura
        path: app/coverage.xml
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: true

# ============================================================================
# BUILD STAGE - Parallel Docker image builds
# ============================================================================

.build-template: &build-template
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    # Docker-in-Docker configuration
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - echo "[AUTH] Logging into GitLab Container Registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  after_script:
    - docker logout $CI_REGISTRY || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      changes:
        - app/**/*
        - collector/**/*
        - postgres/**/*
        - redis/**/*
        - frontend/**/*
        - Dockerfile*
        - requirements.txt
        - docker-compose.yml
        - .gitlab-ci.yml
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

build:postgres:
  <<: *build-template
  script:
    - echo "[BUILD] Building PostgreSQL image..."
    - echo "[DEBUG] Docker version"
    - docker version
    - echo "[DEBUG] Docker info"
    - docker info

    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_POSTGRES}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_POSTGRES}:${VERSION_TAG} \
        --tag ${IMAGE_POSTGRES}:${COMMIT_SHORT} \
        --file ./postgres/Dockerfile \
        ./postgres

    - echo "[PUSH] Pushing PostgreSQL image to registry..."
    - docker push ${IMAGE_POSTGRES}:${VERSION_TAG}
    - docker push ${IMAGE_POSTGRES}:${COMMIT_SHORT}
    - echo "[OK] PostgreSQL build completed"

build:redis:
  <<: *build-template
  script:
    - echo "[BUILD] Building Redis image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_REDIS}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_REDIS}:${VERSION_TAG} \
        --tag ${IMAGE_REDIS}:${COMMIT_SHORT} \
        --file ./redis/Dockerfile \
        ./redis

    - echo "[PUSH] Pushing Redis image to registry..."
    - docker push ${IMAGE_REDIS}:${VERSION_TAG}
    - docker push ${IMAGE_REDIS}:${COMMIT_SHORT}
    - echo "[OK] Redis build completed"

build:collector:
  <<: *build-template
  script:
    - echo "[BUILD] Building Collector image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_COLLECTOR}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_COLLECTOR}:${VERSION_TAG} \
        --tag ${IMAGE_COLLECTOR}:${COMMIT_SHORT} \
        --file ./collector/Dockerfile \
        ./collector

    - echo "[PUSH] Pushing Collector image to registry..."
    - docker push ${IMAGE_COLLECTOR}:${VERSION_TAG}
    - docker push ${IMAGE_COLLECTOR}:${COMMIT_SHORT}
    - echo "[OK] Collector build completed"

build:app:
  <<: *build-template
  script:
    - echo "[BUILD] Building Flask App image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_APP}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_APP}:${VERSION_TAG} \
        --tag ${IMAGE_APP}:${COMMIT_SHORT} \
        --file ./app/Dockerfile \
        ./app

    - echo "[PUSH] Pushing Flask App image to registry..."
    - docker push ${IMAGE_APP}:${VERSION_TAG}
    - docker push ${IMAGE_APP}:${COMMIT_SHORT}
    - echo "[OK] Flask App build completed"

build:frontend:
  <<: *build-template
  script:
    - echo "[BUILD] Building Frontend image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_FRONTEND}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_FRONTEND}:${VERSION_TAG} \
        --tag ${IMAGE_FRONTEND}:${COMMIT_SHORT} \
        --file ./frontend/Dockerfile \
        ./frontend

    - echo "[PUSH] Pushing Frontend image to registry..."
    - docker push ${IMAGE_FRONTEND}:${VERSION_TAG}
    - docker push ${IMAGE_FRONTEND}:${COMMIT_SHORT}
    - echo "[OK] Frontend build completed"

# ============================================================================
# DEPLOY STAGE - SSH deployment to production server
# ============================================================================

.deploy-template: &deploy-template
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client curl docker-cli
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      when: on_success
    - when: manual

deploy:production:
  <<: *deploy-template
  environment:
    name: production
    url: https://blacklist.nxtd.co.kr
  script:
    - echo "[DEPLOY] Deploying to production server..."
    - echo "Target host - $DEPLOY_HOST"
    - echo "Deploy user - $DEPLOY_USER"

    # Create deployment script
    - |
      cat > deploy.sh <<'DEPLOY_EOF'
      #!/bin/bash
      set -e

      echo "[DEPLOY] Starting deployment..."
      cd /opt/blacklist

      # Backup current state
      echo "[BACKUP] Creating pre-deployment backup..."
      docker-compose ps > deployment-backup-$(date +%Y%m%d-%H%M%S).txt

      # Pull latest images from registry
      echo "[PULL] Pulling latest images..."
      echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
      docker-compose -f docker-compose.prod.yml pull

      # Stop old containers (keep data volumes)
      echo "[STOP] Stopping old containers..."
      docker-compose -f docker-compose.prod.yml down --remove-orphans

      # Start new containers
      echo "[START] Starting new containers..."
      docker-compose -f docker-compose.prod.yml up -d

      # Wait for services to be ready
      echo "[WAIT] Waiting for services to start..."
      sleep 30

      # Check health
      echo "[HEALTH] Checking service health..."
      docker-compose -f docker-compose.prod.yml ps

      echo "[OK] Deployment completed successfully"
      DEPLOY_EOF

    - chmod +x deploy.sh

    # Execute deployment via SSH
    - scp deploy.sh ${DEPLOY_USER}@${DEPLOY_HOST}:/tmp/deploy.sh
    - |
      ssh ${DEPLOY_USER}@${DEPLOY_HOST} "
        export CI_REGISTRY=$CI_REGISTRY
        export CI_REGISTRY_USER=$CI_REGISTRY_USER
        export CI_REGISTRY_PASSWORD=$CI_REGISTRY_PASSWORD
        bash /tmp/deploy.sh
        rm /tmp/deploy.sh
      "

    - echo "[SUCCESS] Production deployment completed"
    - echo "Service URL - https://blacklist.nxtd.co.kr"

deploy:development:
  <<: *deploy-template
  environment:
    name: development
    url: https://blacklist.jclee.me
  script:
    - echo "[DEPLOY] Deploying to development server..."
    - echo "Target host - $DEV_DEPLOY_HOST"

    # Similar deployment script for development
    - |
      ssh ${DEPLOY_USER}@${DEV_DEPLOY_HOST} "
        cd /opt/blacklist-dev
        echo '$CI_REGISTRY_PASSWORD' | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
        docker-compose -f docker-compose.dev.yml pull
        docker-compose -f docker-compose.dev.yml up -d --force-recreate
        docker-compose -f docker-compose.dev.yml ps
      "

    - echo "[SUCCESS] Development deployment completed"

  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: on_success
    - when: manual

# ============================================================================
# VERIFY STAGE - Health checks and smoke tests
# ============================================================================

verify:production:
  stage: verify
  image: curlimages/curl:latest
  script:
    - echo "[VERIFY] Running production health checks..."

    # Wait for services to stabilize
    - sleep 10

    # Health check endpoints
    - |
      echo "[CHECK] Testing application health endpoint..."
      for i in $(seq 1 5); do
        if curl -f -s -o /dev/null -w "%{http_code}" https://blacklist.nxtd.co.kr/health | grep -q "200"; then
          echo "[OK] Application health check passed"
          break
        else
          echo "[RETRY] Attempt $i failed, retrying in 10s..."
          sleep 10
        fi
      done

    # API smoke tests
    - |
      echo "[CHECK] Testing API endpoints..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://blacklist.nxtd.co.kr/api/stats)
      if [ "$HTTP_CODE" -eq 200 ]; then
        echo "[OK] API stats endpoint responding"
      else
        echo "[ERROR] API stats endpoint returned $HTTP_CODE"
        exit 1
      fi

    # Database connectivity test
    - |
      echo "[CHECK] Testing database connectivity via API..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://blacklist.nxtd.co.kr/api/monitoring/metrics)
      if [ "$HTTP_CODE" -eq 200 ]; then
        echo "[OK] Database connectivity verified"
      else
        echo "[ERROR] Database check failed with code $HTTP_CODE"
        exit 1
      fi

    - echo "[SUCCESS] All production verification checks passed"

  environment:
    name: production
    url: https://blacklist.nxtd.co.kr

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      when: on_success
    - when: manual

  dependencies: []
  needs: ["deploy:production"]

verify:development:
  stage: verify
  image: curlimages/curl:latest
  script:
    - echo "[VERIFY] Running development health checks..."
    - sleep 5

    - |
      if curl -f https://blacklist.jclee.me/health; then
        echo "[OK] Development health check passed"
      else
        echo "[ERROR] Development health check failed"
        exit 1
      fi

  environment:
    name: development
    url: https://blacklist.jclee.me

  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: on_success
    - when: manual

  needs: ["deploy:development"]

# ============================================================================
# CLEANUP STAGE - Registry maintenance
# ============================================================================

cleanup:registry:
  stage: cleanup
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "[CLEANUP] Starting registry cleanup..."
    - echo "Registry - $CI_REGISTRY"
    - echo "Project - $CI_PROJECT_PATH"

    # List all tags for each image
    - |
      for component in postgres redis collector app frontend; do
        echo "[INFO] Checking blacklist-${component} tags..."

        # Get all tags via GitLab API
        TAGS=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_API_TOKEN" \
          "https://gitlab.jclee.me/api/v4/projects/${CI_PROJECT_ID}/registry/repositories" | \
          jq -r ".[] | select(.name | contains(\"blacklist-${component}\")) | .id")

        if [ -n "$TAGS" ]; then
          echo "[INFO] Found repository ID for blacklist-${component}"
          # Note: Actual deletion requires additional API calls
          # Keep last 10 tags, delete older ones
          echo "[INFO] Registry cleanup for blacklist-${component} - keep last 10 tags"
        fi
      done

    - echo "[OK] Registry cleanup completed"

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      when: manual
    - if: $CI_PIPELINE_SOURCE == "schedule"

  allow_failure: true

# ============================================================================
# ROLLBACK JOB - Manual rollback to previous version
# ============================================================================

rollback:production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client docker-cli
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
  script:
    - echo "[ROLLBACK] Rolling back production deployment..."
    - echo "Previous commit - $ROLLBACK_COMMIT_SHA"

    # SSH to server and rollback
    - |
      ssh ${DEPLOY_USER}@${DEPLOY_HOST} "
        cd /opt/blacklist
        echo '$CI_REGISTRY_PASSWORD' | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin

        # Pull previous version images
        export ROLLBACK_TAG=${ROLLBACK_COMMIT_SHA:-previous}
        docker-compose -f docker-compose.prod.yml pull

        # Restart with previous images
        docker-compose -f docker-compose.prod.yml down
        docker-compose -f docker-compose.prod.yml up -d

        echo '[ROLLBACK] Completed - services restarted with previous version'
      "

    - echo "[SUCCESS] Rollback completed"

  environment:
    name: production
    url: https://blacklist.nxtd.co.kr

  when: manual
  needs: []

# ============================================================================
