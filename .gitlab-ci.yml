# GitLab CI/CD: Air-Gapped Build Pipeline
# Triggers on main/master branch push and manual runs
# Features: Security scan, parallel Docker builds, registry push
# Deployment: Manual offline transfer (see scripts/package-single-image.sh)

stages:
  - validate
  - security
  - build
  - cleanup

variables:
  # GitLab-provided variables (auto-configured)
  # CI_REGISTRY: registry.jclee.me
  # CI_REGISTRY_USER: gitlab-ci-token
  # CI_REGISTRY_PASSWORD: $CI_JOB_TOKEN
  # CI_REGISTRY_IMAGE: registry.jclee.me/jclee/blacklist

  # Docker build optimization
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_BUILDKIT: 1

  # Component image names
  IMAGE_POSTGRES: "${CI_REGISTRY_IMAGE}/blacklist-postgres"
  IMAGE_REDIS: "${CI_REGISTRY_IMAGE}/blacklist-redis"
  IMAGE_COLLECTOR: "${CI_REGISTRY_IMAGE}/blacklist-collector"
  IMAGE_APP: "${CI_REGISTRY_IMAGE}/blacklist-app"
  IMAGE_FRONTEND: "${CI_REGISTRY_IMAGE}/blacklist-frontend"

# ============================================================================
# VALIDATE STAGE - Quick environment checks
# ============================================================================

validate:environment:
  stage: validate
  image: alpine:latest
  script:
    - echo "[OK] GitLab CI/CD environment validation"
    - echo "CI_COMMIT_BRANCH=$CI_COMMIT_BRANCH"
    - echo "CI_REGISTRY=$CI_REGISTRY"
    - echo "CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE"
    - echo "CI_COMMIT_SHA=$CI_COMMIT_SHA"
    - echo "[OK] Validation passed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

# ============================================================================
# SECURITY STAGE - Dependency scanning
# ============================================================================

security:python-scan:
  stage: security
  image: python:3.11-slim
  timeout: 10m
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - script_failure
  before_script:
    - |
      echo "[INSTALL] Installing safety with retry..."
      for i in $(seq 1 3); do
        if pip install safety; then
          echo "[OK] Safety installed successfully"
          break
        else
          echo "[RETRY] Installation attempt $i failed, retrying in 5s..."
          sleep 5
          if [ $i -eq 3 ]; then
            echo "[ERROR] Failed to install safety after 3 attempts"
            exit 1
          fi
        fi
      done
  script:
    - echo "[SECURITY] Scanning Python dependencies for vulnerabilities..."
    - CRITICAL_FOUND=false

    # Scan app dependencies
    - |
      if [ -f app/requirements.txt ]; then
        echo "[SCAN] Checking app/requirements.txt..."
        safety check --file=app/requirements.txt --json > app-safety-report.json || true

        # Check for critical vulnerabilities
        if safety check --file=app/requirements.txt --output json | jq -e '.vulnerabilities[] | select(.severity == "critical")' > /dev/null 2>&1; then
          echo "[ERROR] Critical vulnerabilities found in app dependencies"
          CRITICAL_FOUND=true
        fi

        safety check --file=app/requirements.txt || echo "[WARN] Vulnerabilities found in app dependencies"
      fi

    # Scan collector dependencies
    - |
      if [ -f collector/requirements.txt ]; then
        echo "[SCAN] Checking collector/requirements.txt..."
        safety check --file=collector/requirements.txt --json > collector-safety-report.json || true

        # Check for critical vulnerabilities
        if safety check --file=collector/requirements.txt --output json | jq -e '.vulnerabilities[] | select(.severity == "critical")' > /dev/null 2>&1; then
          echo "[ERROR] Critical vulnerabilities found in collector dependencies"
          CRITICAL_FOUND=true
        fi

        safety check --file=collector/requirements.txt || echo "[WARN] Vulnerabilities found in collector dependencies"
      fi

    # Fail pipeline if critical vulnerabilities found
    - |
      if [ "$CRITICAL_FOUND" = true ]; then
        echo "[FAIL] Pipeline blocked due to critical security vulnerabilities"
        exit 1
      fi

    - echo "[OK] Python security scan completed - no critical issues"

  artifacts:
    paths:
      - "*-safety-report.json"
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: false  # Fail pipeline on critical vulnerabilities

security:javascript-scan:
  stage: security
  image: node:20-slim
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - script_failure
  script:
    - echo "[SECURITY] Scanning JavaScript dependencies for vulnerabilities..."

    # Scan frontend dependencies
    - |
      if [ -f frontend/package.json ]; then
        cd frontend
        echo "[SCAN] Checking frontend dependencies..."

        # npm audit with retry
        for i in $(seq 1 3); do
          if npm audit --json > ../frontend-audit-report.json 2>&1; then
            echo "[OK] npm audit completed"
            break
          else
            echo "[RETRY] npm audit attempt $i failed, retrying in 5s..."
            sleep 5
          fi
        done

        npm audit --audit-level=moderate || echo "[WARN] Vulnerabilities found in frontend dependencies"
        cd ..
      fi

    - echo "[OK] JavaScript security scan completed"

  artifacts:
    paths:
      - "*-audit-report.json"
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: true

security:run-tests:
  stage: security
  image: python:3.11-slim
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  before_script:
    - cd app
    - |
      echo "[INSTALL] Installing Python dependencies with retry..."
      for i in $(seq 1 3); do
        if pip install -r requirements.txt; then
          echo "[OK] Dependencies installed successfully"
          break
        else
          echo "[RETRY] Installation attempt $i failed, retrying in 5s..."
          sleep 5
          if [ $i -eq 3 ]; then
            echo "[ERROR] Failed to install dependencies after 3 attempts"
            exit 1
          fi
        fi
      done
  script:
    - echo "[TEST] Running test suite..."
    - pytest --cov=core --cov-report=term-missing --cov-report=xml || echo "[WARN] Some tests failed"
    - echo "[OK] Tests completed"

  artifacts:
    paths:
      - app/coverage.xml
    reports:
      coverage_report:
        coverage_format: cobertura
        path: app/coverage.xml
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: true

# ============================================================================
# BUILD STAGE - Parallel Docker image builds
# ============================================================================

.build-template: &build-template
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  timeout: 20m  # Build timeout
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - script_failure  # Retry on build failures
  variables:
    # Docker-in-Docker configuration
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    # BuildKit optimization
    DOCKER_BUILDKIT: 1
    COMPOSE_DOCKER_CLI_BUILD: 1
  before_script:
    - echo "[AUTH] Logging into GitLab Container Registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    # Wait for Docker daemon to be ready
    - |
      for i in $(seq 1 30); do
        if docker info > /dev/null 2>&1; then
          echo "[OK] Docker daemon ready"
          break
        fi
        echo "[WAIT] Waiting for Docker daemon ($i/30)..."
        sleep 2
      done
  after_script:
    - docker logout $CI_REGISTRY || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      changes:
        - app/**/*
        - collector/**/*
        - postgres/**/*
        - redis/**/*
        - frontend/**/*
        - Dockerfile*
        - requirements.txt
        - docker-compose.yml
        - .gitlab-ci.yml
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

build:postgres:
  <<: *build-template
  script:
    - echo "[BUILD] Building PostgreSQL image..."
    - echo "[DEBUG] Docker version"
    - docker version
    - echo "[DEBUG] Docker info"
    - docker info

    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_POSTGRES}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_POSTGRES}:${VERSION_TAG} \
        --tag ${IMAGE_POSTGRES}:${COMMIT_SHORT} \
        --file ./postgres/Dockerfile \
        ./postgres

    - echo "[PUSH] Pushing PostgreSQL image to registry..."
    - docker push ${IMAGE_POSTGRES}:${VERSION_TAG}
    - docker push ${IMAGE_POSTGRES}:${COMMIT_SHORT}
    - echo "[OK] PostgreSQL build completed"

build:redis:
  <<: *build-template
  script:
    - echo "[BUILD] Building Redis image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_REDIS}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_REDIS}:${VERSION_TAG} \
        --tag ${IMAGE_REDIS}:${COMMIT_SHORT} \
        --file ./redis/Dockerfile \
        ./redis

    - echo "[PUSH] Pushing Redis image to registry..."
    - docker push ${IMAGE_REDIS}:${VERSION_TAG}
    - docker push ${IMAGE_REDIS}:${COMMIT_SHORT}
    - echo "[OK] Redis build completed"

build:collector:
  <<: *build-template
  script:
    - echo "[BUILD] Building Collector image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_COLLECTOR}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_COLLECTOR}:${VERSION_TAG} \
        --tag ${IMAGE_COLLECTOR}:${COMMIT_SHORT} \
        --file ./collector/Dockerfile \
        ./collector

    - echo "[PUSH] Pushing Collector image to registry..."
    - docker push ${IMAGE_COLLECTOR}:${VERSION_TAG}
    - docker push ${IMAGE_COLLECTOR}:${COMMIT_SHORT}
    - echo "[OK] Collector build completed"

build:app:
  <<: *build-template
  script:
    - echo "[BUILD] Building Flask App image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_APP}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_APP}:${VERSION_TAG} \
        --tag ${IMAGE_APP}:${COMMIT_SHORT} \
        --file ./app/Dockerfile \
        ./app

    - echo "[PUSH] Pushing Flask App image to registry..."
    - docker push ${IMAGE_APP}:${VERSION_TAG}
    - docker push ${IMAGE_APP}:${COMMIT_SHORT}
    - echo "[OK] Flask App build completed"

build:frontend:
  <<: *build-template
  script:
    - echo "[BUILD] Building Frontend image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_FRONTEND}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_FRONTEND}:${VERSION_TAG} \
        --tag ${IMAGE_FRONTEND}:${COMMIT_SHORT} \
        --file ./frontend/Dockerfile \
        ./frontend

    - echo "[PUSH] Pushing Frontend image to registry..."
    - docker push ${IMAGE_FRONTEND}:${VERSION_TAG}
    - docker push ${IMAGE_FRONTEND}:${COMMIT_SHORT}
    - echo "[OK] Frontend build completed"

# ============================================================================
# CLEANUP STAGE - Registry maintenance
# ============================================================================

cleanup:registry:
  stage: cleanup
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "[CLEANUP] Starting registry cleanup..."
    - echo "Registry - $CI_REGISTRY"
    - echo "Project - $CI_PROJECT_PATH"

    # List all tags for each image
    - |
      for component in postgres redis collector app frontend; do
        echo "[INFO] Checking blacklist-${component} tags..."

        # Get all tags via GitLab API
        TAGS=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_API_TOKEN" \
          "https://gitlab.jclee.me/api/v4/projects/${CI_PROJECT_ID}/registry/repositories" | \
          jq -r ".[] | select(.name | contains(\"blacklist-${component}\")) | .id")

        if [ -n "$TAGS" ]; then
          echo "[INFO] Found repository ID for blacklist-${component}"
          # Note: Actual deletion requires additional API calls
          # Keep last 10 tags, delete older ones
          echo "[INFO] Registry cleanup for blacklist-${component} - keep last 10 tags"
        fi
      done

    - echo "[OK] Registry cleanup completed"

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      when: manual
    - if: $CI_PIPELINE_SOURCE == "schedule"

  allow_failure: true
