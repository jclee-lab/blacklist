# GitLab CI/CD: Full AutoDevOps Pipeline
# Triggers on main/master branch push and manual runs
# Features: Security scan, parallel builds, Portainer deployment, health checks

stages:
  - validate
  - security
  - build
  - deploy
  - verify

variables:
  # GitLab-provided variables (auto-configured)
  # CI_REGISTRY: registry.jclee.me
  # CI_REGISTRY_USER: gitlab-ci-token
  # CI_REGISTRY_PASSWORD: $CI_JOB_TOKEN
  # CI_REGISTRY_IMAGE: registry.jclee.me/jclee/blacklist

  # Docker build optimization
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_BUILDKIT: 1

  # Component image names
  IMAGE_POSTGRES: "${CI_REGISTRY_IMAGE}/blacklist-postgres"
  IMAGE_REDIS: "${CI_REGISTRY_IMAGE}/blacklist-redis"
  IMAGE_COLLECTOR: "${CI_REGISTRY_IMAGE}/blacklist-collector"
  IMAGE_APP: "${CI_REGISTRY_IMAGE}/blacklist-app"
  IMAGE_FRONTEND: "${CI_REGISTRY_IMAGE}/blacklist-frontend"

# ============================================================================
# VALIDATE STAGE - Quick environment checks
# ============================================================================

validate:environment:
  stage: validate
  image: alpine:latest
  script:
    - echo "[OK] GitLab CI/CD environment validation"
    - echo "CI_COMMIT_BRANCH=$CI_COMMIT_BRANCH"
    - echo "CI_REGISTRY=$CI_REGISTRY"
    - echo "CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE"
    - echo "CI_COMMIT_SHA=$CI_COMMIT_SHA"
    - echo "[OK] Validation passed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

# ============================================================================
# SECURITY STAGE - Dependency scanning
# ============================================================================

security:python-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    - pip install safety
  script:
    - echo "[SECURITY] Scanning Python dependencies for vulnerabilities..."

    # Scan app dependencies
    - |
      if [ -f app/requirements.txt ]; then
        echo "[SCAN] Checking app/requirements.txt..."
        safety check --file=app/requirements.txt --json > app-safety-report.json || true
        safety check --file=app/requirements.txt || echo "[WARN] Vulnerabilities found in app dependencies"
      fi

    # Scan collector dependencies
    - |
      if [ -f collector/requirements.txt ]; then
        echo "[SCAN] Checking collector/requirements.txt..."
        safety check --file=collector/requirements.txt --json > collector-safety-report.json || true
        safety check --file=collector/requirements.txt || echo "[WARN] Vulnerabilities found in collector dependencies"
      fi

    - echo "[OK] Python security scan completed"

  artifacts:
    paths:
      - "*-safety-report.json"
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: true

security:javascript-scan:
  stage: security
  image: node:20-slim
  script:
    - echo "[SECURITY] Scanning JavaScript dependencies for vulnerabilities..."

    # Scan frontend dependencies
    - |
      if [ -f frontend/package.json ]; then
        cd frontend
        echo "[SCAN] Checking frontend dependencies..."
        npm audit --json > ../frontend-audit-report.json || true
        npm audit --audit-level=moderate || echo "[WARN] Vulnerabilities found in frontend dependencies"
        cd ..
      fi

    - echo "[OK] JavaScript security scan completed"

  artifacts:
    paths:
      - "*-audit-report.json"
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: true

security:run-tests:
  stage: security
  image: python:3.11-slim
  before_script:
    - cd app
    - pip install -r requirements.txt
  script:
    - echo "[TEST] Running test suite..."
    - pytest --cov=core --cov-report=term-missing --cov-report=xml || echo "[WARN] Some tests failed"
    - echo "[OK] Tests completed"

  artifacts:
    paths:
      - app/coverage.xml
    reports:
      coverage_report:
        coverage_format: cobertura
        path: app/coverage.xml
    expire_in: 30 days
    when: always

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

  allow_failure: true

# ============================================================================
# BUILD STAGE - Parallel Docker image builds
# ============================================================================

.build-template: &build-template
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    # Docker-in-Docker configuration
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - echo "[AUTH] Logging into GitLab Container Registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  after_script:
    - docker logout $CI_REGISTRY || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      changes:
        - app/**/*
        - collector/**/*
        - postgres/**/*
        - redis/**/*
        - frontend/**/*
        - Dockerfile*
        - requirements.txt
        - docker-compose.yml
        - .gitlab-ci.yml
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual

build:postgres:
  <<: *build-template
  script:
    - echo "[BUILD] Building PostgreSQL image..."
    - echo "[DEBUG] Docker version"
    - docker version
    - echo "[DEBUG] Docker info"
    - docker info

    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_POSTGRES}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_POSTGRES}:${VERSION_TAG} \
        --tag ${IMAGE_POSTGRES}:${COMMIT_SHORT} \
        --file ./postgres/Dockerfile \
        ./postgres

    - echo "[PUSH] Pushing PostgreSQL image to registry..."
    - docker push ${IMAGE_POSTGRES}:${VERSION_TAG}
    - docker push ${IMAGE_POSTGRES}:${COMMIT_SHORT}
    - echo "[OK] PostgreSQL build completed"

build:redis:
  <<: *build-template
  script:
    - echo "[BUILD] Building Redis image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_REDIS}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_REDIS}:${VERSION_TAG} \
        --tag ${IMAGE_REDIS}:${COMMIT_SHORT} \
        --file ./redis/Dockerfile \
        ./redis

    - echo "[PUSH] Pushing Redis image to registry..."
    - docker push ${IMAGE_REDIS}:${VERSION_TAG}
    - docker push ${IMAGE_REDIS}:${COMMIT_SHORT}
    - echo "[OK] Redis build completed"

build:collector:
  <<: *build-template
  script:
    - echo "[BUILD] Building Collector image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_COLLECTOR}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_COLLECTOR}:${VERSION_TAG} \
        --tag ${IMAGE_COLLECTOR}:${COMMIT_SHORT} \
        --file ./collector/Dockerfile \
        ./collector

    - echo "[PUSH] Pushing Collector image to registry..."
    - docker push ${IMAGE_COLLECTOR}:${VERSION_TAG}
    - docker push ${IMAGE_COLLECTOR}:${COMMIT_SHORT}
    - echo "[OK] Collector build completed"

build:app:
  <<: *build-template
  script:
    - echo "[BUILD] Building Flask App image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_APP}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_APP}:${VERSION_TAG} \
        --tag ${IMAGE_APP}:${COMMIT_SHORT} \
        --file ./app/Dockerfile \
        ./app

    - echo "[PUSH] Pushing Flask App image to registry..."
    - docker push ${IMAGE_APP}:${VERSION_TAG}
    - docker push ${IMAGE_APP}:${COMMIT_SHORT}
    - echo "[OK] Flask App build completed"

build:frontend:
  <<: *build-template
  script:
    - echo "[BUILD] Building Frontend image..."
    - export VERSION_TAG="latest"
    - export COMMIT_SHORT=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

    - |
      docker build \
        --cache-from ${IMAGE_FRONTEND}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg BUILD_DATE=${BUILD_DATE} \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --tag ${IMAGE_FRONTEND}:${VERSION_TAG} \
        --tag ${IMAGE_FRONTEND}:${COMMIT_SHORT} \
        --file ./frontend/Dockerfile \
        ./frontend

    - echo "[PUSH] Pushing Frontend image to registry..."
    - docker push ${IMAGE_FRONTEND}:${VERSION_TAG}
    - docker push ${IMAGE_FRONTEND}:${COMMIT_SHORT}
    - echo "[OK] Frontend build completed"

# ============================================================================
# DEPLOY STAGE - Portainer webhook deployment
# ============================================================================

deploy:portainer-webhook:
  stage: deploy
  image: curlimages/curl:latest
  needs:
    - build:postgres
    - build:redis
    - build:collector
    - build:app
    - build:frontend
  script:
    - echo "[DEPLOY] Triggering Portainer deployment..."

    - |
      if [ -z "${PORTAINER_WEBHOOK_URL}" ]; then
        echo "[ERROR] PORTAINER_WEBHOOK_URL not configured"
        echo "[INFO] Please set the webhook URL in GitLab CI/CD variables:"
        echo "   Settings > CI/CD > Variables > Add variable"
        echo "   Key: PORTAINER_WEBHOOK_URL"
        echo "   Value: https://portainer.jclee.me/api/stacks/webhooks/YOUR_WEBHOOK_ID"
        exit 1
      fi

    # Retry logic (3 attempts)
    - |
      for i in 1 2 3; do
        echo "[DEPLOY] Webhook attempt $i/3..."

        WEBHOOK_RESPONSE=$(curl -s -X POST "${PORTAINER_WEBHOOK_URL}" \
          --connect-timeout 30 \
          --max-time 60 \
          -w "\n%{http_code}")

        HTTP_CODE=$(echo "$WEBHOOK_RESPONSE" | tail -1)
        RESPONSE_BODY=$(echo "$WEBHOOK_RESPONSE" | head -n -1)

        if [ "$HTTP_CODE" == "204" ] || [ "$HTTP_CODE" == "200" ]; then
          echo "[OK] Webhook deployment triggered successfully (HTTP $HTTP_CODE)"
          if [ -n "$RESPONSE_BODY" ]; then
            echo "[INFO] Response: $RESPONSE_BODY"
          fi
          break
        else
          echo "[DEPLOY] Webhook attempt $i failed (HTTP $HTTP_CODE)"
          if [ $i -lt 3 ]; then
            echo "[INFO] Retrying in 10 seconds..."
            sleep 10
          else
            echo "[ERROR] Webhook deployment failed after 3 attempts"
            exit 1
          fi
        fi
      done

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - when: manual

# ============================================================================
# VERIFY STAGE - Health checks
# ============================================================================

verify:health-check:
  stage: verify
  image: curlimages/curl:latest
  needs:
    - deploy:portainer-webhook
  script:
    - echo "[WAIT] Waiting for containers to start (60 seconds)..."
    - sleep 60

    - echo "[VERIFY] Performing health checks..."
    - export MAX_RETRIES=10
    - export RETRY_DELAY=15

    - |
      for i in $(seq 1 $MAX_RETRIES); do
        echo "[VERIFY] Health check attempt $i/$MAX_RETRIES..."

        if curl -s --connect-timeout 10 --max-time 30 "${PRD_URL}/health" | grep -q '"status":"healthy"'; then
          echo "[OK] Production health check passed!"

          # API functionality verification
          if curl -s "${PRD_URL}/api/stats" | grep -q '"success":true'; then
            echo "[OK] API functionality verified"
          else
            echo "[WARN] API check failed but service is running"
          fi
          break
        else
          echo "[VERIFY] Health check attempt $i failed"
          if [ $i -lt $MAX_RETRIES ]; then
            echo "[INFO] Retrying in ${RETRY_DELAY} seconds..."
            sleep $RETRY_DELAY
          else
            echo "[ERROR] Health check failed after $MAX_RETRIES attempts"
            echo "[DEBUG] Final diagnostics:"
            curl -s -I "${PRD_URL}/health" || echo "Connection failed"
            exit 1
          fi
        fi
      done

    - echo "[SUCCESS] === DEPLOYMENT SUCCESSFUL ==="
    - echo "[OK] All 5 components built & deployed!"
    - echo "[INFO] Registry: ${CI_REGISTRY}"
    - echo "[INFO] Production URL: ${PRD_URL}"
    - echo "[INFO] Deployment Method: Portainer Webhook"

  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
    - when: manual

# ============================================================================
# HOW TO USE THIS PIPELINE
# ============================================================================
#
# 1. Configure GitLab CI/CD Variables (Settings > CI/CD > Variables):
#    - PORTAINER_WEBHOOK_URL: https://portainer.jclee.me/api/stacks/webhooks/YOUR_ID
#    - PRD_URL: https://blacklist.jclee.me (or https://blacklist.nxtd.co.kr)
#
# 2. Push to main/master branch:
#    git add .
#    git commit -m "Your commit message"
#    git push origin main
#
# 3. Pipeline will automatically:
#    - Run security scans (Python + JavaScript)
#    - Build 5 Docker images in parallel
#    - Push to GitLab Container Registry (registry.jclee.me)
#    - Deploy via Portainer webhook
#    - Verify with health checks
#
# 4. Manual runs:
#    - Go to GitLab CI/CD > Pipelines
#    - Click "Run pipeline"
#    - Select branch and run
#
# 5. GitLab Container Registry:
#    - Automatic authentication with CI_JOB_TOKEN
#    - Images: registry.jclee.me/jclee/blacklist/*
#    - Tags: latest, {commit-sha-8}
#
# ============================================================================
