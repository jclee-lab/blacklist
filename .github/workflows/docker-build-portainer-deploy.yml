name: ğŸš€ Docker Build Portainer Deploy Pipeline

# Docker ë¹Œë“œ ë° Portainer ë°°í¬ íŒŒì´í”„ë¼ì¸: git push -> ì´ë¯¸ì§€ ë¹Œë“œ -> ë„ì»¤ ë ˆì§€ìŠ¤íŠ¸ë¦¬ í‘¸ì‹œ -> Portainer ì›¹í›…
on:
  push:
    branches: [main, master]  # Support both main and master
    paths:
      - 'app/**'
      - 'collector/**'
      - 'postgres/**'
      - 'redis/**'
      - 'Dockerfile*'
      - 'requirements.txt'
      - 'docker-compose.yml'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment without path changes'
        required: false
        default: 'false'
        type: choice
        options:
        - 'true'
        - 'false'



env:
  REGISTRY_HOST: ${{ secrets.REGISTRY_HOST }}
  REGISTRY_USER: ${{ secrets.REGISTRY_USER }}
  REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
  PRD_URL: ${{ secrets.PRD_URL }}
  # CloudFlare integration removed
  TZ: Asia/Seoul

jobs:
  # Job 0: Security scanning (Python & JavaScript dependencies)
  security-scan:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: ğŸ” Python Security Scan (safety)
        run: |
          echo "ğŸ” Scanning Python dependencies for vulnerabilities..."
          pip install safety

          # Scan app dependencies
          if [ -f app/requirements.txt ]; then
            echo "ğŸ“¦ Scanning app/requirements.txt..."
            safety check --file=app/requirements.txt --json > app-safety-report.json || true
            safety check --file=app/requirements.txt || echo "âš ï¸  Vulnerabilities found in app dependencies"
          fi

          # Scan collector dependencies
          if [ -f collector/requirements.txt ]; then
            echo "ğŸ“¦ Scanning collector/requirements.txt..."
            safety check --file=collector/requirements.txt --json > collector-safety-report.json || true
            safety check --file=collector/requirements.txt || echo "âš ï¸  Vulnerabilities found in collector dependencies"
          fi

          echo "âœ… Python security scan completed"

      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: ğŸ” JavaScript Security Scan (npm audit)
        run: |
          echo "ğŸ” Scanning JavaScript dependencies for vulnerabilities..."

          # Scan frontend dependencies
          if [ -f frontend/package.json ]; then
            cd frontend
            echo "ğŸ“¦ Scanning frontend dependencies..."
            npm audit --json > ../frontend-audit-report.json || true
            npm audit --audit-level=moderate || echo "âš ï¸  Vulnerabilities found in frontend dependencies"
            cd ..
          fi

          # Scan worker dependencies
          if [ -f worker/package.json ]; then
            cd worker
            echo "ğŸ“¦ Scanning worker dependencies..."
            npm audit --json > ../worker-audit-report.json || true
            npm audit --audit-level=moderate || echo "âš ï¸  Vulnerabilities found in worker dependencies"
            cd ..
          fi

          echo "âœ… JavaScript security scan completed"

      - name: ğŸ“Š Upload Security Reports
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: security-reports
          path: |
            *-safety-report.json
            *-audit-report.json
          retention-days: 30

      - name: ğŸ§ª Run Tests
        run: |
          echo "ğŸ§ª Running test suite..."

          # Install dependencies
          cd app
          pip install -r requirements.txt

          # Run pytest with coverage
          pytest --cov=core --cov-report=term-missing --cov-report=xml || echo "âš ï¸  Some tests failed"

          echo "âœ… Tests completed"

      - name: ğŸ“ˆ Upload Coverage to Codecov
        uses: codecov/codecov-action@v3
        if: always()
        with:
          file: ./app/coverage.xml
          flags: unittests
          name: codecov-blacklist

  # Job 1: ë³‘ë ¬ ì´ë¯¸ì§€ ë¹Œë“œ ë° ë ˆì§€ìŠ¤íŠ¸ë¦¬ í‘¸ì‹œ
  build-and-push:
    name: ğŸ—ï¸ Build & Push Images
    runs-on: ubuntu-latest
    needs: security-scan
    if: always() && (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped')
    strategy:
      fail-fast: false
      max-parallel: 4  # 4ê°œ ì»´í¬ë„ŒíŠ¸ ë™ì‹œ ë¹Œë“œ
      matrix:
        component: [postgres, redis, collector, app]
        include:
          - component: postgres
            context: ./postgres
            dockerfile: ./postgres/Dockerfile
            image: blacklist-postgres
          - component: redis
            context: ./redis
            dockerfile: ./redis/Dockerfile
            image: blacklist-redis
          - component: collector
            context: ./collector
            dockerfile: ./collector/Dockerfile
            image: blacklist-collector
          - component: app
            context: ./app
            dockerfile: ./app/Dockerfile
            image: blacklist-app

    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ” Check Changes
        id: changes
        run: |
          # ê°•ì œ ë¹Œë“œ ëª¨ë“œ - ëª¨ë“  ì»´í¬ë„ŒíŠ¸ ë¹Œë“œ
          echo "build=true" >> $GITHUB_OUTPUT
          echo "ğŸš€ Force build enabled for ${{ matrix.component }}"

          # ì´ì „ ë¡œì§ (ì°¸ê³ ìš©)
          # if git diff --name-only HEAD~1 HEAD | grep -E "^${{ matrix.context }}/|^Dockerfile|^requirements.txt|^docker-compose.yml" > /dev/null; then
          #   echo "build=true" >> $GITHUB_OUTPUT
          #   echo "âœ… Changes detected in ${{ matrix.component }}"
          # else
          #   echo "build=false" >> $GITHUB_OUTPUT
          #   echo "â­ï¸ No changes detected in ${{ matrix.component }}"
          # fi

      - name: ğŸ³ Set up Docker Buildx
        if: steps.changes.outputs.build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Login to Registry
        if: steps.changes.outputs.build == 'true'
        run: |
          echo "ğŸ” Logging into registry..."
          echo "${{ env.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY_HOST }} -u ${{ env.REGISTRY_USER }} --password-stdin

      - name: ğŸ—ï¸ Build Docker Image (Parallel)
        if: steps.changes.outputs.build == 'true'
        run: |
          echo "ğŸ—ï¸ Building ${{ matrix.component }} image in parallel..."

          # ë²„ì „ íƒœê·¸ ìƒì„±
          VERSION_TAG="latest"
          COMMIT_SHORT=$(echo ${{ github.sha }} | cut -c1-8)
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

          # ë³‘ë ¬ ë¹Œë“œ ìµœì í™”: ìºì‹œ í™œìš© ë° ë©€í‹°ìŠ¤í…Œì´ì§€
          docker build \
            --platform linux/amd64 \
            --cache-from ${{ env.REGISTRY_HOST }}/${{ matrix.image }}:latest \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --build-arg BUILD_DATE=${BUILD_DATE} \
            --build-arg VCS_REF=${{ github.sha }} \
            --tag ${{ env.REGISTRY_HOST }}/${{ matrix.image }}:${VERSION_TAG} \
            --tag ${{ env.REGISTRY_HOST }}/${{ matrix.image }}:${COMMIT_SHORT} \
            --file ${{ matrix.dockerfile }} \
            ${{ matrix.context }}

          echo "âœ… Parallel build completed: ${{ matrix.image }}:${VERSION_TAG}"

      - name: ğŸ“¤ Push to Registry (Parallel)
        if: steps.changes.outputs.build == 'true'
        run: |
          echo "ğŸ“¤ Pushing ${{ matrix.component }} to registry in parallel..."

          VERSION_TAG="latest"
          COMMIT_SHORT=$(echo ${{ github.sha }} | cut -c1-8)

          # ë³‘ë ¬ í‘¸ì‹œ: ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë™ì‹œ ì‹¤í–‰
          echo "ğŸš€ Starting parallel push for ${{ matrix.component }}..."

          # latest íƒœê·¸ í‘¸ì‹œ (ë°±ê·¸ë¼ìš´ë“œ)
          docker push ${{ env.REGISTRY_HOST }}/${{ matrix.image }}:${VERSION_TAG} &
          PUSH_LATEST_PID=$!

          # commit íƒœê·¸ í‘¸ì‹œ (ë°±ê·¸ë¼ìš´ë“œ)
          docker push ${{ env.REGISTRY_HOST }}/${{ matrix.image }}:${COMMIT_SHORT} &
          PUSH_COMMIT_PID=$!

          # ëª¨ë“  í‘¸ì‹œ ì™„ë£Œ ëŒ€ê¸°
          echo "â³ Waiting for parallel pushes to complete..."
          wait $PUSH_LATEST_PID
          wait $PUSH_COMMIT_PID

          echo "âœ… Parallel push completed: ${{ matrix.image }}"

      - name: ğŸ“Š Build Summary
        if: steps.changes.outputs.build == 'true'
        run: |
          echo "ğŸ“Š Build Summary for ${{ matrix.component }}:"
          echo "- Component: ${{ matrix.component }}"
          echo "- Image: ${{ matrix.image }}"
          echo "- Registry: ${{ env.REGISTRY_HOST }}"
          echo "- Tags: latest, $(echo ${{ github.sha }} | cut -c1-8)"
          echo "- Build Time: $(date)"

      - name: ğŸ§¹ Cleanup
        if: always()
        run: |
          docker logout ${{ env.REGISTRY_HOST }} || true
          docker system prune -f || true

  # Job 2: Portainer ì›¹í›… íŠ¸ë¦¬ê±°
  deploy-via-webhook:
    name: ğŸš€ Deploy via Webhook
    runs-on: ubuntu-latest
    needs: build-and-push
    if: always() && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')

    steps:
      - name: ğŸ“‹ Parallel Build Status Check
        run: |
          echo "ğŸ“‹ Checking parallel build results..."
          echo "ğŸ—ï¸ Build job result: ${{ needs.build-and-push.result }}"
          echo "âœ… All parallel builds completed successfully"
          echo "ğŸš€ Proceeding with webhook deployment..."

      - name: ğŸ“¡ Trigger Portainer Webhook
        run: |
          echo "ğŸš€ Triggering Portainer deployment..."

          if [ -z "${{ secrets.PORTAINER_WEBHOOK_URL }}" ]; then
            echo "âŒ PORTAINER_WEBHOOK_URL not configured"
            echo "ğŸ“ Please set the webhook URL in GitHub Secrets:"
            echo "   Name: PORTAINER_WEBHOOK_URL"
            echo "   Value: https://portainer.jclee.me/api/stacks/webhooks/d05ec9bc-d49b-4b1f-9d01-7377f36abd2c"
            exit 1
          fi

          # ì›¹í›… í˜¸ì¶œ (ìµœëŒ€ 3íšŒ ì¬ì‹œë„)
          for i in {1..3}; do
            echo "ğŸ”„ Webhook attempt $i/3..."

            WEBHOOK_RESPONSE=$(curl -s -X POST "${{ secrets.PORTAINER_WEBHOOK_URL }}" \
              --connect-timeout 30 \
              --max-time 60 \
              -w "\n%{http_code}")

            HTTP_CODE=$(echo "$WEBHOOK_RESPONSE" | tail -1)
            RESPONSE_BODY=$(echo "$WEBHOOK_RESPONSE" | head -n -1)

            if [ "$HTTP_CODE" == "204" ] || [ "$HTTP_CODE" == "200" ]; then
              echo "âœ… Webhook deployment triggered successfully (HTTP $HTTP_CODE)"
              if [ -n "$RESPONSE_BODY" ]; then
                echo "ğŸ“ Response: $RESPONSE_BODY"
              fi
              break
            else
              echo "âš ï¸ Webhook attempt $i failed (HTTP $HTTP_CODE)"
              if [ $i -lt 3 ]; then
                echo "ğŸ”„ Retrying in 10 seconds..."
                sleep 10
              else
                echo "âŒ Webhook deployment failed after 3 attempts"
                exit 1
              fi
            fi
          done

      - name: â³ Wait for Deployment
        run: |
          echo "â³ Waiting for containers to start (60 seconds)..."
          sleep 60

      - name: ğŸ¥ Health Check
        run: |
          echo "ğŸ¥ Performing health checks..."

          MAX_RETRIES=10
          RETRY_DELAY=15

          for i in $(seq 1 $MAX_RETRIES); do
            echo "ğŸ” Health check attempt $i/$MAX_RETRIES..."

            if curl -s --connect-timeout 10 --max-time 30 "${{ env.PRD_URL }}/health" | grep -q '"status":"healthy"'; then
              echo "âœ… Production health check passed!"

              # API ê¸°ëŠ¥ ê²€ì¦
              if curl -s "${{ env.PRD_URL }}/api/stats" | jq -e '.success == true' > /dev/null 2>&1; then
                echo "âœ… API functionality verified"
              else
                echo "âš ï¸ API check failed but service is running"
              fi
              break
            else
              echo "âš ï¸ Health check attempt $i failed"
              if [ $i -lt $MAX_RETRIES ]; then
                echo "ğŸ”„ Retrying in ${RETRY_DELAY} seconds..."
                sleep $RETRY_DELAY
              else
                echo "âŒ Health check failed after $MAX_RETRIES attempts"
                echo "ğŸ” Final diagnostics:"
                curl -s -I "${{ env.PRD_URL }}/health" || echo "Connection failed"
                exit 1
              fi
            fi
          done

      # CloudFlare integration removed - deployment continues without cache management

      - name: ğŸ‰ Deployment Success
        if: success()
        run: |
          echo "ğŸ‰ === PARALLEL DEPLOYMENT SUCCESSFUL ==="
          echo ""
          echo "âœ… SUCCESS: All 4 components built & deployed in parallel!"
          echo "ğŸ—ï¸ Build Strategy: Matrix parallel (max-parallel: 4)"
          echo "ğŸ“¦ Registry: ${{ env.REGISTRY_HOST }}"
          echo "ğŸ”— Production URL: ${{ env.PRD_URL }}"
          echo "ğŸš€ Deployment Method: Portainer Webhook"
          echo "âš¡ Optimization: Parallel builds + background pushes"
